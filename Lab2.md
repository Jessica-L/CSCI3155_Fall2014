# Lab 2
####Title:        Writeup for Lab 2 Questions
####Team Members: Jessica Lynch and Noah Dillon


_1. Grammars: Synthetic Examples._ 

_A ::= A & A | V_  
_V ::= a | b_  

_(a) Rewrite the above grammar using the following two judgment forms:_
    
_A &isin; AObjects_  
_V &isin; VObjects_  
    
**SOLUTION:**
		
Axioms:

a &isin; VObjects; b &isin; VObjects

			----------------			----------------
			a is in VObjects			b is in VObjects


Premises and conclusion:

			   S(a) is in AObjects S(b) is in AObjects
			   ---------------------------------------
			              V is in AObjects
			              
			                     |
			                     V
			                      	              
			             S(V) is in AObjects
			             -------------------
			              V&V is in AObjects
			              
			                     |
			                     V
			                      
			              V&V is in AObjects
			           ------------------------
			           S(V)&S(V) is in AObjects
			             		
			             		
_(b) Show that the grammar in part (a) is ambiguous:_

**SOLUTION:**
    
		Since V => a or b, we can have: 
				A => A & A 
				  => (A & A) & (A & A) 
				  => a & a & a & a 
				   
		However, we can also have:
				A => (A & A) & V 
				  => (V & (A & A)) & V
				  => (a & (V & V)) & a 
				  => (a & (a & a)) & a 
				  => a & a & a & a.
				  
		NOTE: This is only one example of how the grammar in part (a) 
		is ambiguous.  
		
		The above example proves that more than one path can lead us to
		a single result, a & a & a & a. Therefore, the grammar in part
		(a) is ambiguous.

_(c) Define the language defined by the following grammar:_
  
_S ::= A | B | C_  
_A ::= aA | a_  
_B ::= bB | &epsilon;_  
_C ::= cC | c_  
  
  
**SOLUTION:**
    
		L(S) = { a^n, b^n, c^n; n >= 0 }

		L(A) = { a^n; n >= 1  }
		L(B) = { b^m; m >= 0 }
		L(C) = { c^n; n >= 1  }

_(d) Which of the sentences below are in the language generated by the following grammar? (Use derivations.)_
  
_S ::= AaBb_  
_A ::= Ab | b_  
_B ::= aB | a_  
  
  
**SOLUTION:**
    
		1. baab
		
		   S ::= AaBb => baBb since A => b 
		              => baab since B => a
		   
		   The above derivation shows that baab IS IN the language
		   generated by the above grammar.
	 
	    
	    2. bbbab
	    
	       S ::= AaBb => AbaBb since A => Ab
					  => AbbaBb 
					  => bbbaBb since A => b
					  => bbbaab since B => a
					  
		   The above grammar generates a language that ensures that all 
		   sentences derived from contain more than one 'a' sequentially.
		   Since B => aB or a and S ::= AaBb, the grammar S already 
		   contains a single 'a' followed by grammar B which adds one or
		   more a's to any resulting sentence. 
		   
		        L(S) = { (b)^n(a)^m(b)^k; n >= 1  m > 1  k = 1 }
		        
		   Therefore, bbbab IS NOT IN the language generated by the
		   above grammar.
		
		
		3. bbaaaaa
		
	       S ::= AaBb => AbaBb since A => Ab
					  => bbaBb since A => b
					  => bbaaBb since B => aB
					  => bbaaaBb => (b)^2(a)^5(b)^1 since B => aB or a
		
		   The above grammar generates a language that ensures that all 
		   sentences derived from it terminate in 'b' NOT 'a'. 
		   
		        L(S) = { (b)^n(a)^m(b)^k; n >= 1  m > 1  k = 1 }
		   
		   Therefore, bbaaaaa IS NOT IN the language generated by the
		   above grammar.
		 
		   
		4. bbaab
		
		   S ::= AaBb => AbaBb since A => Ab | b
					  => bbaBb 
					  => bbaab since B => aB | a
		
		   The above derivation shows that baab IS IN the language
		   generated by the above grammar.
		   
_(e) Which of the below sentences are in the language generated by the following grammar? (Use parse trees.)_
  
_S ::= aScB | A | b_  
_A ::= cA | c_  
_B ::= d | A_  
  
  
**SOLUTION:**
    
		1. abcd
		
				S
			  /| |\
			 a S c B
			   |   |
			   b   d
			    
		   The above parse tree shows that abcd IS IN the language 
		   generated by the above grammar.
		
		2. acccbd
		
				S
			  /| |\
			 a S c B
			   |   |
			   A   d
			  /|
			 c A
			   |
			   c
		   
		   The above parse tree shows the resulting sentence of acccd
		   since b is not in the grammar B or the grammar A, so we can
		   conclude that acccbd cannot be obtained by using the language
		   generated by the above grammar. Therefore, acccbd IS NOT IN 
		   this language.
		   
		3. acccbcc
		
				S
			  /| |\
			 a S c B
			   |   |
			   A   A
			  /|   |\
			 c A   c A
			   |     |
			   c     c

		
		   The above parse tree shows a resulting sentence of accccc 
		   since b is not in grammar B or in grammar A, so we can conclude 
		   that acccbd cannot be obtained by using the language generated 
		   by the above grammar. Therefore, acccbcc IS NOT IN this 
		   language.
		
		4. acd
		
				S
			  /| |\
			 a S c B
			  /|   |
			 A b   d
			 |
			 c
		   
		   The above parse tree shows the resulting sentences as either
		   accd or abcd, so we can conclude that acd IS NOT IN the
		   language generated by the above grammar.
		   
		5. accc
		   
				S
			  /| |\
			 a S c B
			   |   |
			   A   A
			   |   |
			   c   c
			   
		   The above parse tree shows that accc IS IN the language 
		   generated by the above grammar.   
		   
_2. Grammars: Understanding a Language._

_e ::= operand | e operator operand_  
    
_e ::= operand esuffix_  
_esuffix ::= operator operand esuffix | &epsilon;_   

_(a) Consider the above two grammars for expressions e.  In both grammars, operator and operand are the same._
	    
**SOLUTION:**
  
		i. Intuitively describe the expressions generated by the two grammars:
		
		From the former grammar, we have:
		
			L(e) = { (operand)^n (operator operand)^m; n = 1  m >= 0 }
		
		From the latter grammar, we have:
		
			L(e) = { (operand)^n (operator operand)^m; n = 1  m >= 0 }
			
		
		ii. Do these grammars generate the same or different expressions? Explain.
		
		These grammars can generate the same expression but the latter uses left
		associativity (expands to the left) whereas the former uses right
		associativity (expands to the right).  Therefore, these grammars DO NOT
		generate  the same expression.
						
		Explanation using parse trees:
		
			For e ::= operand | e operator operand, we can have the following which
			expands to the LEFT:
			
						e
						|
				 ----------------
				/		|		 \
			   e    operator     operand
			   |
			operand
			
					
			For e ::= operand esuffix and esuffix ::= operator operand esuffix | epsilon
			where epsilon signifies "Empty", we can have the following which expands to
			the RIGHT:
			
						e
						|
				 ----------------
				/		 		 \
			operand            esuffix
								  |
					       ----------------
						  /	 	  |  	   \
					operator    operand    esuffix
											  |
										   epsilon
			
_(b) Write a Scala expression to determine if - has higher precedence than << or vice versa._  
_Make sure that you are checking for precedence in your expression and not for left or right_  
_associativity. Use parentheses to indicate the possible abstract syntax trees, and then_  
_show the evaluation of the possible expressions. Finally, explain how you arrived at the_  
_relative precedence of and << based on the output that you saw in the Scala interpreter._   

val a  
val b  
  
e ::= term << e | e << term | term  
term ::= a - b  



_(c) Give a BNF grammar for floating point numbers that are made up of a fraction (e.g., 5.6 or 3.123 or -2.5)_  
_followed by an optional exponent (e.g., E10 or E-10). The exponent, if it exists, is the letter ‘E’_  
_followed by an integer. For example, the following are floating point numbers: 3.5E3, 3.123E30, -2.5E2,_  
_-2.5E-2, and 3.5. The following are not examples of floating point numbers: 3.E3, E3, and 3.0E4.5._  
_More precisely, our floating point numbers must have a decimal point, do not have leading zeros, can_  
_have any number of trailing zeros, non-zero exponents (if it exists), must have non-zero fraction to_  
_have an exponent, and cannot have a ‘-’ in front of a zero number. The exponent cannot have leading zeros._    

		<e> ::=  <I.efterm> | <Ne> | <N>  

		<term> ::= <EN> | epsilon  

		<N> ::= 0 | 1 | 2 | 3 | ... | 9   

		<I> ::= 1 | 2 | 3 | ... | 9  





